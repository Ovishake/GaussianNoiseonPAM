Observations:

By: Avishek Mukherjee

The received signal gets noisy for the higher values of QAM.

For Example, 64-QAM is very noisy compared to that of 4-QAM.

Also the BER goes decreasing for larger constellation like 16-QAM and 64-QAM. 10e6 poionts take a long time to run but 10e3 is also divisible by 4 and 4*4 and also by 4*4*4. I know that you said 10e6 to accomodate 100*100*100 as 25*25*25 different bits but i have added an if condition that pads zeros to the end of the symbols by doing a modulo of the number of points by the constellation number M, where M corresponds to the M of the M QAM. I know that this is incorrect and i should have appended the zeros in a different way, but it acheives faster run times.

if mod(n,k) > 0
            n = n + (k - mod(n,k));
            %MAKING IT AS GENERIC AS POSSIBLE
            %PUT IT IN A FUNCTION AS THE PROGRAM BECOMES UNWIELDY
            %CUBERSOME
            %ALTHOUGH THIS IS NOT CORRECT
            % IN PROJECT YOU ASKED QUESTIONS WITH MULTIPLES OF 4
            % MULTIPLES OF 4 CAN DIVIDE THE INPUT YOU WANT
end

Also each iteration of the modulate QAM plots a graph that shows the noisy symbols.

I also scaled the GrayCodes generated by the dec2gray.m that you gave by multiplying the constellation points by 2, as the dmin between points was 1 and then shifting it to the left by subtracting 3 from the points.

in_phase = 2 * in_phase;
quadrature = 2 * quadrature;
in_phase = in_phase - 3;
quadrature = quadrature -3;

The above code scales the output to fit it into the constellation points that we read in the Proakis book. The output of de2gray gives us 1 to 4, but we have to make it to -3 -1 1 3 to fit it in the knowledge we learnt. I've also written a function called as ampgen that generates the cartesian product of all the points in a constellation if you enter the constellation size M. Please refer to the attached files.


